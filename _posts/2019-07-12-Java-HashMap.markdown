---
layout:     post
title:      "HashMap实现：除留余数法的性能提高"
subtitle:   " \"巧妙的设计\""
date:       2019-07-12 14:24:00
author:     "Snorlaxa"
header-img: "img/2019-07-12/bg.jpg"
catalog: true
tags:
    - Java源码
---

## HashMap散列函数的设计

+ **HashMap本质上是什么**

    HashMap作为一个map，是能够存放键值对的数据结构，为了查找快速我们希望使用散列表的方式存放键值对。

    做法是使用Key的HashCode值进行一次hash操作，并将得到的值按照散列表的方式找到其在数组中的位置，这个过程就是数据结构中的哈希查找了。

    ![HashMap](/img/2019-07-12/hashmap.jpg "HashMap实现")

+ **哈希查找需要考虑的问题**

    根据数据结构的知识，哈希查找需要考虑hash函数的设计和解决冲突的方法。

    + Hash函数的设计

    为了使对象在数组中分布较均匀，采用除留余数法是比较合适的，也就是将得到的hash值对哈希表长度取余。而很多书认为哈希表长度应是较大的质数，而且最好不要是2的整数幂。书上的解释是一个二进制数除以2的整数幂时，结果为该二进制数的后几位，前面的位丢失了，属于信息损失。个人认为不认同这个观点，取模是为了将大区域中的元素映射到小区域中，这期间必然会信息丢失，与被除数的设计无关。Java中偏偏把哈希表长度设为$2^n$，显然也是不认同这个观点。

    + 解决冲突的方法

    为了方便扩展和提高利用率，链地址法会比开放定址法更加合适。而当冲突很多时，链地址法的查找效率也会退化成链表，所以java将长度大于8的链表改进成红黑树，提高了查找效率。

+ **性能的提高**

    首先要知道的是除法和取模都是很消耗性能的，应尽量减少此类操作。

    使用位运算来取代mod操作是很明智的方法，为了做到这一点，被除数的二进制表示一定要是全1，满足这个条件时取模和与运算&是一致的。

    HashMap长度是不断变化，如何获取这个全1的二进制被除数就是问题。在HashMap底层的设计中，有一个很重要的点是哈希表的长度为2的整数幂（HashMap以2倍数拓展），而这个长度减1就得到全1的二进制数。所以jdk的做法是把哈希表的长度减1作为数值取模的对象，这样就成功将取模运算转化为与运算。提高了性能。
